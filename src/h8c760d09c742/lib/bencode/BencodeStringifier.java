package h8c760d09c742.lib.bencode;

import java.util.Map;

/**
 * Generation of printable representations of Bencode entities. 
 * Elements of lists and dictionaries are converted recursively.
 */
public class BencodeStringifier implements BencodeVisitor {

	private final StringBuilder str;
	private final String prefix;
	private final String indent;
	private final boolean dumpStrings;
	private final BencodeIO io;
	
	/**
	 * Setup of a Bencode object structure to String converstion.
	 * @param str A {@link StringBuilder} to which the representations of the processed objects will be appended.
	 * @see BencodeStringifier#BencodeStringifier(String, String, boolean, BencodeIO)
	 */
	public BencodeStringifier(StringBuilder str, String prefix, String indent, boolean dumpStrings, BencodeIO io) {
		this.str = str;
		this.prefix = prefix;
		this.indent = indent;
		this.dumpStrings = dumpStrings;
		this.io = io;
	}
	
	/**
	 * Setup of a Bencode object structure to String conversion.
	 * @param prefix String added once at the beginning of each line.
	 * @param indent String added to the beginning of each line again for every recursion.
	 * @param dumpStrings Output hex-dumps for string-objects.
	 * @param io Optional reference to a reader or writer to determine the byte offsets of each object in the buffer it was read from or written to.
	 */
	public BencodeStringifier(String prefix, String indent, boolean dumpStrings, BencodeIO io) {
		this(new StringBuilder(), prefix, indent, dumpStrings, io);
	}
	
	/**
	 * Retrieves the String representations of the Bencode objects this Stringifyer has visited.
	 * @return Total result generated by this Stringifier.
	 */
	@Override
	public String toString() {
		return str.toString();
	}
	
	private BencodeStringifier descend() {
		return new BencodeStringifier(str, prefix + indent, indent, dumpStrings, io);
	}
	
	private void printPos(StringBuilder str, BencodeObject obj) {
		if (io != null) {
			BencodeIO.Range pos = io.getPosition(obj);
			if (pos != null) {
				str.append(" @").append(pos.getStart())
					.append("-").append(pos.getEnd());	
			}
		}
	}
	
	/**
	 * Processes a Bencode object including its sub-structure.
	 * @param obj Top-level object of the structure to process.
	 * @return This Stringifier.
	 */
	public BencodeStringifier visit(BencodeObject obj) {
		try {
			obj.accept(this);
		} catch (BencodeException e) {
			throw new IllegalArgumentException(e);
		}
		return this;
	}
	
	@Override
	public void visit(BencodeInteger obj) throws BencodeException {
		str.append("Integer(").append(obj.getValue()).append(")");
		printPos(str, obj);
	}
	
	@Override
	public void visit(BencodeString obj) throws BencodeException {
		byte[] data = obj.getData();
		str.append("String(").append(data.length).append(")");
		printPos(str, obj);
		if (dumpStrings) str.append("\n").append(bytesToString(prefix + indent, data, data.length % 20 == 0 ? 20 : 16));
	}
	
	@Override
	public void visit(BencodeList list) throws BencodeException {
		str.append("List(").append(list.getCount()).append(")");
		printPos(str, list);
		for (BencodeObject entry : list) {
			str.append('\n').append(prefix).append(indent);
			entry.accept(descend());
		}
	}
	
	@Override
	public void visit(BencodeDictionary dict) throws BencodeException {
		str.append("Dictionary(").append(dict.getCount()).append(")");
		printPos(str, dict);
		for (Map.Entry<String, BencodeObject> e : dict.getEntries()) {
			str.append('\n').append(prefix).append(indent).append("[").append(e.getKey()).append("]: ");
			e.getValue().accept(descend());
		}
	}
	
	private static String bytesToString(String prefix, byte[] b, int wrap) {
		StringBuilder sb = new StringBuilder();
		sb.append(prefix);
		for (int n = 0; n < b.length; n++) {
			if (wrap > 0 && n > 0 && (n % wrap) == 0) {
				sb.append('\n');
				sb.append(prefix);
			}
			sb.append(String.format("%02X", b[n]));
		}
		return sb.toString();
	}

}
